///////////////////////////////////////////////////////////////////////////////
// File name: JSB_WM8994_STM32F769Discovery.c
// Author: J S Bladen 2018
// Description: wm8994 interface for STM32F769 Discovery board.
///////////////////////////////////////////////////////////////////////////////
// Notes:
// => Requires optical digital receiver:
//    => E.g. ORJ-5.
//       => 3 pins. Facing socket entrance with pins pointing down, pins are numbered from right to left.
//          => Pin 1: Out.
//          => Pin 2: 0V.
//          => Pin 3: 3V3.
// => Requires USE_HAL_TIM_REGISTER_CALLBACKS symbol to be defined as 1 e.g. add "USE_HAL_TIM_REGISTER_CALLBACKS=1" to C compiler symbols in "Tool Settings".
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "main.h"
#include "tim.h"
#include "spdifrx.h"
#include "JSB_SPDIFRX.h"

///////////////////////////////////////////////////////////////////////////////
// Callbacks:

__weak void SPDIFRX_Locked_Callback(uint8_t Value)
{
}

__weak void SPDIFRX_MuteOutput_Callback(uint8_t Value)
{
}

__weak void SPDIFRX_SetOutputSampleRate_Callback(uint32_t Value)
{
}

__weak void SPDIFRX_ClearOutputBuffer()
{
}

///////////////////////////////////////////////////////////////////////////////

static uint8_t Started = 0;
static float BufferReadPosition = 0.0;
static float SPDIFRX_BufferSampleStepSize = 0.0f;
static uint8_t BufferReadPositionInitialized = 0;
static uint32_t NumConsecutiveInputBufferReadPointerInRange = 0;
static uint8_t WasLocked = 0;
static uint8_t DisableInterruptHandler = 0;
static uint8_t ReceiveErrorOccurred = 0;

static AudioSample24_t SPDIFRX_IncomingSamples[SPDIFRX_Buffer_NumSamples];
static AudioSample24_t SPDIFRX_SamplesSnapShot[SPDIFRX_Buffer_NumSamples];

///////////////////////////////////////////////////////////////////////////////
// Interface variables:

float SPDIFRX_TransferGain = 1.0f;

///////////////////////////////////////////////////////////////////////////////

static uint8_t SPDIFRX_ErrorCallbackCalled = 0;

void HAL_SPDIFRX_ErrorCallback(SPDIFRX_HandleTypeDef *hspdif)
// This doesn't appear to get called if the audio input is disconnected.
{
  SPDIFRX_ErrorCallbackCalled = 1;
}

///////////////////////////////////////////////////////////////////////////////

static uint32_t InputSampleRate = 0;
static uint32_t OutputSampleRate = 0;

static float AudioInput_MeasuredSampleRate = 0.0f;
// static uint16_t AudioInput_MeasuredSampleRate_PreviousCount = 0;
// static uint16_t AudioInput_MeasuredSampleRate_DeltaCount = 0;
static uint32_t AudioInput_MeasuredSampleRate_FrameCounter = 0;

static void CaptureCallback(TIM_HandleTypeDef *htim)
{
  ++AudioInput_MeasuredSampleRate_FrameCounter;

//  uint16_t AudioInput_MeasuredSampleRate_Count;
//  AudioInput_MeasuredSampleRate_Count = __HAL_TIM_GetCounter(htim);
//  AudioInput_MeasuredSampleRate_DeltaCount = AudioInput_MeasuredSampleRate_Count - AudioInput_MeasuredSampleRate_PreviousCount;
//  AudioInput_MeasuredSampleRate_PreviousCount = AudioInput_MeasuredSampleRate_Count;
}

///////////////////////////////////////////////////////////////////////////////

uint32_t SPDIFRX_GetInputSampleRate()
{
  return InputSampleRate;
}

///////////////////////////////////////////////////////////////////////////////
// Debug:

int32_t InputSampleRateHistory_NumValues = 0;

/*
static float sqr(float A)
{
  return A * A;
}

static float Debug_CalculateInputSampleRateJitter(float InputSampleRate)
{
  #define InputSampleRateHistory_MaxNumValues 100

  int32_t InputSampleRateIndex;
  static float InputSampleRateHistory[InputSampleRateHistory_MaxNumValues];

  memmove(&InputSampleRateHistory[1], &InputSampleRateHistory[0], (InputSampleRateHistory_MaxNumValues - 1) * sizeof(InputSampleRateHistory[0]));
  InputSampleRateHistory[0] = InputSampleRate;
  ++InputSampleRateHistory_NumValues;
  if (InputSampleRateHistory_NumValues > InputSampleRateHistory_MaxNumValues)
    InputSampleRateHistory_NumValues = InputSampleRateHistory_MaxNumValues;

  float Total = 0.0f;
  for (InputSampleRateIndex = 0; InputSampleRateIndex < InputSampleRateHistory_NumValues; ++InputSampleRateIndex)
    Total += InputSampleRateHistory[InputSampleRateIndex];
  float Mean = Total / InputSampleRateHistory_NumValues;

  float TotalValueMinusMeanAllSquared = 0.0f;
  for (InputSampleRateIndex = 0; InputSampleRateIndex < InputSampleRateHistory_NumValues; ++InputSampleRateIndex)
    TotalValueMinusMeanAllSquared += sqr(InputSampleRateHistory[InputSampleRateIndex] - Mean);
  float StandardDeviation = sqrt(TotalValueMinusMeanAllSquared / (InputSampleRateHistory_NumValues - 1));

  return StandardDeviation;
}
*/

///////////////////////////////////////////////////////////////////////////////

float IntegralOfNormalizedError = 0.0f;
float PreviousNormalizedError = 0.0f;

static float Calculate_SPDIFRX_BufferSampleStepSize(uint8_t *o_InputBufferReadPointerInRange)
// Test cases:
// => Input sample rate: 48000Hz Output sample rate: 48000Hz.
// => Input sample rate: 44100Hz Output sample rate: 44100Hz.
// => Input sample rate: 48000Hz Output sample rate: 44100Hz.
{
  #define TargetReadLagProportion 0.75f

  float SPDIFRX_BufferWriteIndex, NumSamplesReadIsBehindWrite, ActualReadLagProportion;
//  float DerivativeOfNormalizedError = 0.0f;

  SPDIFRX_BufferWriteIndex = SPDIFRX_Buffer_NumSamples - 0.5f * hspdif.hdmaDrRx->Instance->NDTR; // NB: DMA counts in channel samples not LR samples. It also counts backward. It also starts at the maximum value, not one less. However, it is zero before it becomes active [PJB].

  if (!BufferReadPositionInitialized)
  {
    BufferReadPosition = Wrap_int(SPDIFRX_BufferWriteIndex - TargetReadLagProportion * SPDIFRX_Buffer_NumSamples, SPDIFRX_Buffer_NumSamples);
    BufferReadPositionInitialized = 1;
  }

  NumSamplesReadIsBehindWrite = SPDIFRX_BufferWriteIndex - BufferReadPosition;
  if (NumSamplesReadIsBehindWrite < 0) NumSamplesReadIsBehindWrite += SPDIFRX_Buffer_NumSamples;

  ActualReadLagProportion = (float)NumSamplesReadIsBehindWrite / (float)SPDIFRX_Buffer_NumSamples;
  float UnclampedNormalizedError = (1.0f / (1.0f - TargetReadLagProportion)) * (ActualReadLagProportion - TargetReadLagProportion);
  float ClampedNormalizedError = Clamp_float(UnclampedNormalizedError, -1.0f, 1.0f);

  *o_InputBufferReadPointerInRange = ((UnclampedNormalizedError >= -1.0f) || (UnclampedNormalizedError <= 1.0f));

//  float NominalLocalSampleRate = hsai_BlockA1.Init.AudioFrequency;

  // V0:
  // float InputSampleRate = NominalLocalSampleRate + 20 * ClampedNormalizedError; // !!! Should be 48 but that adds too much frequency and hence resampling jitter.
  // SPDIFRX_BufferSampleStepSize = InputSampleRate / NominalLocalSampleRate;

  // V1: Good performance.
  IntegralOfNormalizedError = 0.95f * IntegralOfNormalizedError + ClampedNormalizedError;
  float Kp = (InputSampleFrequencyCaptureHalfRangePPM / 1E6); // This value ensures that the read pointer lag does not result in buffer write / read collisions for supported range of input sampling frequency.
  SPDIFRX_BufferSampleStepSize = ((float)InputSampleRate / (float)OutputSampleRate) * (1.0f + Kp * ClampedNormalizedError + 2E-4 * IntegralOfNormalizedError);

  // V2: Slow to lock.
//  IntegralOfNormalizedError += ClampedNormalizedError;
//  float Kp = (InputSampleFrequencyCaptureHalfRangePPM / 1E6); // This value ensures that the read pointer lag does not result in buffer write / read collisions for supported range of input sampling frequency.
//  SPDIFRX_BufferSampleStepSize = 1.0f + Kp * NormalizedError + 2E-6 * IntegralOfNormalizedError;

  // V3:
//  IntegralOfNormalizedError += ClampedNormalizedError;
//  DerivativeOfNormalizedError = NormalizedError - PreviousNormalizedError;
//  PreviousNormalizedError = ClampedNormalizedError;
//  SPDIFRX_BufferSampleStepSize = 1.0f + 1E-3 * NormalizedError + 1E-3 * IntegralOfNormalizedError + 0.05f * DerivativeOfNormalizedError;

  // Debugging:
  //  float InputSampleRate = SPDIFRX_BufferSampleStepSize * NominalLocalSampleRate;
//  char s[200];
//  float InputSampleRate = SPDIFRX_BufferSampleStepSize * (47991.071428571428571428571428571); // !!!Hardwired.
//  float InputSampleRate_StandardDeviation = Debug_CalculateInputSampleRateJitter(InputSampleRate);
//  sprintf(s, "NSRBW: %8.2f CNE: %8.5f INE: %8.5f SS: %8.5f ISR: %8.2f ISRSD: %8.2f\n",
//    NumSamplesReadIsBehindWrite, ClampedNormalizedError, IntegralOfNormalizedError, SPDIFRX_BufferSampleStepSize, InputSampleRate, InputSampleRate_StandardDeviation);
//  //  sprintf(s, "NSRBW: %8.2f CNE: %8.5f INE: %8.5f DNE: %8.5f SS: %8.5f ISR: %8.2f ISRSD: %8.2f\n",
//  //    NumSamplesReadIsBehindWrite, ClampedNormalizedError, IntegralOfNormalizedError, DerivativeOfNormalizedError, SPDIFRX_BufferSampleStepSize, InputSampleRate, InputSampleRate_StandardDeviation);
//  SendDebugMessage(s);

  return SPDIFRX_BufferSampleStepSize;
}

static uint8_t SPDIFRX_NumTransitionErrors = 0;
static uint8_t SPDIFRX_NumSyncErrors = 0;
static uint8_t SPDIFRX_NumFrameErrors = 0;

void SPDIFRX_GetNumErrors(uint8_t *pNumTransitionErrors, uint8_t *pNumSyncErrors, uint8_t *pNumFrameErrors)
{
  *pNumTransitionErrors = SPDIFRX_NumTransitionErrors;
  *pNumSyncErrors = SPDIFRX_NumSyncErrors;
  *pNumFrameErrors = SPDIFRX_NumFrameErrors;
}

void SPDIFRX_CopySamplesToGivenBuffer(AudioSample24_t *pOutputBuffer, AudioBufferHalf_t AudioBufferHalf)
// ============================================================================
// Notes:
// => The read snapshot start position must be more than half a buffer behind the current SPDIF DMA write position (or else it will read data before it is written).
// => The SPDIF DMA must not write over samples that have not yet been read.
// => Therefore, the read snapshot start position must be more than a half and less than a whole of a buffer behind the current SPDIF DMA write position.
//    => Let ReadPos = "read snapshot start position" wrt "current SPDIF DMA write position", normalized to the size of the buffer.
//    => Then: -1.0 < ReadPos < -0.5
//    => Aim for ReadPos = -0.75
// ============================================================================
// Timings:
// => Situation:
//    => STM32: 216 MHz. I+D caches enabled. Instruction prefetch disabled.
//    => 48000 Hz sample rate.
//    => 640 samples total buffer size (320 samples per half).
// => Time between consecutive calls: 6.667 ms.
// => Total processing time: 1.335 ms.
//    => Time to take snapshot (copy) of 320 stereo samples (8 bytes each => 2560 bytes) using memcpy(): 78 us
//       =>  ~33 MBytes/sec
//    => Time to calculate sample index step size for SPDIF samples: 1.9 us
//    => Time to calculate and use 320 x 2 cubics: 1.255 ms
// => Proportion of available time spent processing samples: 20%
// ============================================================================
{
  uint8_t InputBufferReadPointerInRange, IsLocked;
  uint32_t SampleOffsetIndex, LocalSampleIndex, GlobalSampleIndex;
  int32_t SourceSampleIndex0, SourceSampleIndex1, SourceSampleIndex2, SourceSampleIndex3;
  AudioSample24_t SourceSample0, SourceSample1, SourceSample2, SourceSample3;
  AudioSample24_t TargetSample;

  if (DisableInterruptHandler)
    return;

  uint8_t SPDIFRX_State = hspdif.Instance->CR & 0x03;

  if ((SPDIFRX_State != 0x03) || (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_TERR) != RESET) || (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_SERR) != RESET) || (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_FERR) != RESET))
  {
    if (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_TERR))
      ++SPDIFRX_NumTransitionErrors;
    if (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_SERR))
      ++SPDIFRX_NumSyncErrors;
    if (__HAL_SPDIFRX_GET_FLAG(&hspdif, SPDIFRX_FLAG_FERR))
      ++SPDIFRX_NumFrameErrors;

    ReceiveErrorOccurred = 1;
    DisableInterruptHandler = 1;
    __HAL_SPDIFRX_IDLE(&hspdif);
    SPDIFRX_MuteOutput_Callback(1); //!!! May need to sort out Tick priorities and being called on main thread and in interrupt etc.
    SPDIFRX_Locked_Callback(0);
    WasLocked = 0;
    return;
  }

  // Take snap shot.
  memcpy(SPDIFRX_SamplesSnapShot, SPDIFRX_IncomingSamples, sizeof(SPDIFRX_SamplesSnapShot));

  SPDIFRX_BufferSampleStepSize = Calculate_SPDIFRX_BufferSampleStepSize(&InputBufferReadPointerInRange);

  if (InputBufferReadPointerInRange)
    NumConsecutiveInputBufferReadPointerInRange = Min_int32(NumConsecutiveInputBufferReadPointerInRange + 1, 1000000);
  else
    NumConsecutiveInputBufferReadPointerInRange = 0;

  IsLocked = NumConsecutiveInputBufferReadPointerInRange >= 20; //!!! Hardwired.
  SPDIFRX_Locked_Callback(IsLocked);

  if (IsLocked != WasLocked)
  {
    SPDIFRX_MuteOutput_Callback(!IsLocked);
    WasLocked = IsLocked;
  }

  if (AudioBufferHalf == abhSecondHalf)
    SampleOffsetIndex = SPDIFRX_Buffer_NumSamples / 2;
  else
    SampleOffsetIndex = 0;

  for(LocalSampleIndex = 0; LocalSampleIndex < SPDIFRX_Buffer_NumSamples / 2; ++LocalSampleIndex)
  {
    GlobalSampleIndex = SampleOffsetIndex + LocalSampleIndex;

    double BufferReadPosition_Integral;
    double BufferReadPosition_Fractional;
    BufferReadPosition_Fractional = modf(BufferReadPosition, &BufferReadPosition_Integral);

    SourceSampleIndex0 = Wrap_int((int)(BufferReadPosition_Integral) - 1, SPDIFRX_Buffer_NumSamples);
    SourceSampleIndex1 = Wrap_int(SourceSampleIndex0 + 1, SPDIFRX_Buffer_NumSamples);
    SourceSampleIndex2 = Wrap_int(SourceSampleIndex1 + 1, SPDIFRX_Buffer_NumSamples);
    SourceSampleIndex3 = Wrap_int(SourceSampleIndex2 + 1, SPDIFRX_Buffer_NumSamples);
    SourceSample0 = SPDIFRX_SamplesSnapShot[SourceSampleIndex0];
    SourceSample1 = SPDIFRX_SamplesSnapShot[SourceSampleIndex1];
    SourceSample2 = SPDIFRX_SamplesSnapShot[SourceSampleIndex2];
    SourceSample3 = SPDIFRX_SamplesSnapShot[SourceSampleIndex3];

    TargetSample.Left = CubicInterpolate(SourceSample0.Left, SourceSample1.Left, SourceSample2.Left, SourceSample3.Left, BufferReadPosition_Fractional);
    TargetSample.Right = CubicInterpolate(SourceSample0.Right, SourceSample1.Right, SourceSample2.Right, SourceSample3.Right, BufferReadPosition_Fractional);

    TargetSample.Left *= SPDIFRX_TransferGain;
    TargetSample.Right *= SPDIFRX_TransferGain;

    TargetSample.Left = TargetSample.Left / 256;
    TargetSample.Right = TargetSample.Right / 256;

    pOutputBuffer[GlobalSampleIndex] = TargetSample;

    BufferReadPosition += SPDIFRX_BufferSampleStepSize;
    while (BufferReadPosition >= SPDIFRX_Buffer_NumSamples)
      BufferReadPosition -= SPDIFRX_Buffer_NumSamples;
  }
}

float MeasureInputSampleRate()
{
  AudioInput_MeasuredSampleRate_FrameCounter = 0;
  uint32_t StartTick = HAL_GetTick();
  HAL_Delay(50);
  uint32_t EndTick = HAL_GetTick();
  return 1000.0f * AudioInput_MeasuredSampleRate_FrameCounter / (EndTick - StartTick);

// This approach works fine with the RCA signal from my i7 PC but gives much too much jitter when using optical input from GCA or CD player:
//  uint32_t APB2TimerClockFrequency =  2 * HAL_RCC_GetPCLK2Freq();
//  float AudioInput_MeasuredSampleRate = (double)APB2TimerClockFrequency / (double)AudioInput_MeasuredSampleRate_DeltaCount;
}

uint8_t IsSampleRateInRange(float SampleRateInQuestion, float ReferenceSampleRate)
{
  return fabs((SampleRateInQuestion / ReferenceSampleRate) - 1.0f) <= (InputSampleFrequencyCaptureHalfRangePPM / 1E6);
}

static void InitializeResamplingVariables()
{
  BufferReadPositionInitialized = 0;
  BufferReadPosition = 0.0f;
  IntegralOfNormalizedError = 0.0f;
  PreviousNormalizedError = 0.0f;
  InputSampleRateHistory_NumValues = 0;
  NumConsecutiveInputBufferReadPointerInRange = 0;
  WasLocked = 0;
}

void ClearBuffer()
{
  AudioSample24_t ZeroSample={0,0};
  for(uint32_t SampleIndex = 0; SampleIndex < SPDIFRX_Buffer_NumSamples; ++SampleIndex)
    SPDIFRX_IncomingSamples[SampleIndex] = ZeroSample;
}

void SPDIFRX_SelectInput(uint32_t Value)
{
  uint32_t InputSelection = 0;

  switch(Value)
  {
    case 0: InputSelection = SPDIFRX_INPUT_IN0; break;
    case 1: InputSelection = SPDIFRX_INPUT_IN1; break;
    case 2: InputSelection = SPDIFRX_INPUT_IN2; break;
    case 3: InputSelection = SPDIFRX_INPUT_IN3; break;

    default: Error_Handler();
  }

  hspdif.Instance->CR = (hspdif.Instance->CR & ~SPDIFRX_INPUT_IN3) | InputSelection;
}

uint8_t SPDIFRX_IsStarted()
{
  return Started;
}

uint8_t SPDIFRX_Start(float TargetSampleRate, uint32_t InputChannel, uint8_t ForceOutputSampleRate, uint32_t ForcedOutputSampleRate)
{
  HAL_StatusTypeDef HALResult;

  EnsureFixPresent_Fix_JSB_20191115_SPDIFRX_TIMEOUT_VALUE();

  SPDIFRX_Stop(); // Get the receiver into a known state e.g. after a failed (timed out) start because there was no input.

  InitializeResamplingVariables();

  if (hspdif.State != HAL_SPDIFRX_STATE_READY)
  {
    HAL_DMA_Abort(hspdif.hdmaDrRx); // *** JSB Cube bug fix!!! ***
    HAL_DMA_Abort(hspdif.hdmaCsRx); // *** JSB Cube bug fix!!! ***
    HAL_SPDIFRX_DMAStop(&hspdif);
  }

  // Start input sample rate timer:
  HAL_TIM_RegisterCallback(&htim11, HAL_TIM_IC_CAPTURE_CB_ID, &CaptureCallback);
  HAL_TIM_IC_Stop_IT(&htim11); // Added 22/10/2025
  if (HAL_TIM_IC_Start_IT(&htim11, TIM_CHANNEL_1))
    Error_Handler();

  // Select input channel.
  SPDIFRX_SelectInput(InputChannel);

  // Start SPIDIFRX to measure input sample rate:
  SPDIFRX_ErrorCallbackCalled = 0;
  DisableInterruptHandler = 1;
  ReceiveErrorOccurred = 0;
  HALResult = HAL_SPDIFRX_ReceiveDataFlow_DMA(&hspdif, (uint32_t *)SPDIFRX_IncomingSamples, (sizeof(AudioSample24_t) / sizeof(int32_t)) * SPDIFRX_Buffer_NumSamples);
  if (HALResult == HAL_TIMEOUT)
    return 0;

  // Adapt to sample rate if supported.
  HAL_Delay(50); // Wait for receiver to settle.
  AudioInput_MeasuredSampleRate =  MeasureInputSampleRate();
  if (IsSampleRateInRange(AudioInput_MeasuredSampleRate, SAI_AUDIO_FREQUENCY_44K))
    InputSampleRate = SAI_AUDIO_FREQUENCY_44K;
  else if (IsSampleRateInRange(AudioInput_MeasuredSampleRate, SAI_AUDIO_FREQUENCY_48K))
    InputSampleRate = SAI_AUDIO_FREQUENCY_48K;
  else return 0;

  if (ForceOutputSampleRate)
    OutputSampleRate = ForcedOutputSampleRate;
  else
    OutputSampleRate = InputSampleRate;

  SPDIFRX_SetOutputSampleRate_Callback(OutputSampleRate);

  // Restart SPDIFRX because its clock was likely interrupted and hence its functionality broken when the output sampling rate was set.
  SPDIFRX_Stop(); // Get the receiver into a known state e.g. after a failed (timed out) start because there was no input.
  HALResult = HAL_SPDIFRX_ReceiveDataFlow_DMA(&hspdif, (uint32_t *)SPDIFRX_IncomingSamples, (sizeof(AudioSample24_t) / sizeof(int32_t)) * SPDIFRX_Buffer_NumSamples);
  if (HALResult == HAL_TIMEOUT)
    return 0;

  DisableInterruptHandler = 0;

  Started = 1;

  return 1;
}

void SPDIFRX_Stop()
{
  Started = 0;

  DisableInterruptHandler = 1;
  SPDIFRX_Locked_Callback(0);
  SPDIFRX_ClearOutputBuffer();
  __HAL_SPDIFRX_IDLE(&hspdif);
  ClearBuffer();

  // SPDIFRX_MuteOutput_Callback(1); !!!Clashes with call from interrupt handler:

  // Reset SPDIFRX.
  EnsureFixPresent_Fix_JSB_20191115_HAL_SPDIFRX_DMAStop__DMA_Abort();
  EnsureFixPresent_Fix_JSB_20191115_HAL_SPDIFRX_DMAStop__CR();
  HAL_SPDIFRX_DMAStop(&hspdif);
}

uint8_t SPDIFRX_HasReceiveErrorOccurred()
{
  return ReceiveErrorOccurred;
}

uint8_t SPDIFRX_IsReceiving()
{
  return DisableInterruptHandler ? 0 : 1;
}
